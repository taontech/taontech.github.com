<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Taontech.GitHub.com by taontech</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-tagline">We won! That's all that matters!
         ﻿</h1>
      <h1 class="project-name"> No! The way we win matters</h1>
    </section>

    <section class="main-content">
      <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a></h3>

<!--<p>记录心中点滴</p>-->

<!--<pre><code>$ cd your_repo_root/repo_name-->
<!--$ git fetch origin-->
<!--$ git checkout gh-pages-->
<!--</code></pre>-->

<!--<p>测试使用博客提供静态数据服务功能，<a href="https://taontech.github.io/README.md">这个链接是个测试，链接到README.md</a>.</p>-->

<!--<h3>-->
<!--<a id="designer-templates" class="anchor" href="#designer-templates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Designer Templates</h3>-->

<!--<p>We've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.</p>-->

<!--<h3>-->
<!--<a id="rather-drive-stick" class="anchor" href="#rather-drive-stick" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rather Drive Stick?</h3>-->

<!--<p>If you prefer to not use the automatic generator, push a branch named <code>gh-pages</code> to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator written by our own Tom Preston-Werner. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.</p>-->

<!--<h3>-->
<!--<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Authors and Contributors</h3>-->

<!--<p>You can <a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/#mentioning-users-and-teams" class="user-mention">@mention</a> a GitHub username to generate a link to their profile. The resulting <code>&lt;a&gt;</code> element will link to the contributor's GitHub Profile. For example: In 2007, Chris Wanstrath (<a href="https://github.com/defunkt" class="user-mention">@defunkt</a>), PJ Hyett (<a href="https://github.com/pjhyett" class="user-mention">@pjhyett</a>), and Tom Preston-Werner (<a href="https://github.com/mojombo" class="user-mention">@mojombo</a>) founded GitHub.</p>-->

<!--<h3>-->
<!--<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Support or Contact</h3>-->

<!--<p>Having trouble with Pages? Check out the documentation at <a href="https://help.github.com/pages">https://help.github.com/pages</a> or contact <a href="mailto:support@github.com">support@github.com</a> and we’ll help you sort it out.</p>-->

      <!--<footer class="site-footer">-->

        <!--<span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>-->
      <!--</footer>-->

    <!--</section>-->


   <!-- <div id="info">
      <a href="http://threejs.org" target="_blank">three.js</a> - <span id="birds"></span> webgl gpgpu birds<br/>
      Select <span id="options"></span> birds<br/>
      Move mouse to disturb birds.

    </div>-->
    <script src="build/three.js"></script>
    <script src="js/Detector.js"></script>

    <script src="js/GPUComputationRenderer.js"></script>

    <script id="fragmentShaderPosition" type="x-shader/x-fragment">

			uniform float time;
			uniform float delta;

			void main()	{

				vec2 uv = gl_FragCoord.xy / resolution.xy;
				vec4 tmpPos = texture2D( texturePosition, uv );
				vec3 position = tmpPos.xyz;
				vec3 velocity = texture2D( textureVelocity, uv ).xyz;

				float phase = tmpPos.w;

				phase = mod( ( phase + delta / 5.0 +
					length( velocity.xz ) * delta * 3. +
					max( velocity.y, 0.0 ) * delta * 6. ), 62.83 );
				// phase = tmpPos.w;
				gl_FragColor = vec4( position + velocity * delta * 25. , phase );

			}

		</script>

    <!-- shader for bird's velocity -->
    <script id="fragmentShaderVelocity" type="x-shader/x-fragment">

			uniform float time;
			uniform float testing;
			uniform float delta; // about 0.016
			uniform float seperationDistance; // 20
			uniform float alignmentDistance; // 40
			uniform float cohesionDistance; //
			uniform float freedomFactor;
			uniform vec3 predator;

			const float width = resolution.x;
			const float height = resolution.y;

			const float PI = 3.141592653589793;
			const float PI_2 = PI * 2.0;
			// const float VISION = PI * 0.55;

			float zoneRadius = 40.0;
			float zoneRadiusSquared = 1600.0;

			float separationThresh = 0.45;
			float alignmentThresh = 0.65;

			const float UPPER_BOUNDS = BOUNDS;
			const float LOWER_BOUNDS = -UPPER_BOUNDS;

			const float SPEED_LIMIT = 6.0;

			float rand(vec2 co){
				return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
			}

			void main() {

				zoneRadius = seperationDistance + alignmentDistance + cohesionDistance;
				separationThresh = seperationDistance / zoneRadius;
				alignmentThresh = ( seperationDistance + alignmentDistance ) / zoneRadius;
				zoneRadiusSquared = zoneRadius * zoneRadius;


				vec2 uv = gl_FragCoord.xy / resolution.xy;
				vec3 birdPosition, birdVelocity;

				vec3 selfPosition = texture2D( texturePosition, uv ).xyz;
				vec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;

				float dist;
				vec3 dir; // direction
				float distSquared;

				float seperationSquared = seperationDistance * seperationDistance;
				float cohesionSquared = cohesionDistance * cohesionDistance;

				float f;
				float percent;

				vec3 velocity = selfVelocity;

				float limit = SPEED_LIMIT;

				dir = predator * UPPER_BOUNDS - selfPosition;
				 dir.z = 0.;
				// dir.z *= -0.6;
				dist = length( dir );
				distSquared = dist * dist;

				float preyRadius = 150.0;
				float preyRadiusSq = preyRadius * preyRadius;


				// move birds away from predator
				if (dist < preyRadius) {

					f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;
					velocity += normalize( dir ) * f;
					limit += 5.0;
				}


				// if (testing == 0.0) {}
				// if ( rand( uv + time ) < freedomFactor ) {}


				// Attract flocks to the center
				vec3 central = vec3( 0., 0., 0. );
				dir = selfPosition - central;
				dist = length( dir );

				dir.y *= 2.5;
				velocity -= normalize( dir ) * delta * 15.;

				for (float y=0.0;y<height;y++) {
					for (float x=0.0;x<width;x++) {

						vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;
						birdPosition = texture2D( texturePosition, ref ).xyz;

						dir = birdPosition - selfPosition;
						dist = length(dir);

						if (dist < 0.0001) continue;

						distSquared = dist * dist;

						if (distSquared > zoneRadiusSquared ) continue;

						percent = distSquared / zoneRadiusSquared;

						if ( percent < separationThresh ) { // low

							// Separation - Move apart for comfort
							f = (separationThresh / percent - 1.0) * delta;
							velocity -= normalize(dir) * f;

						} else if ( percent < alignmentThresh ) { // high

							// Alignment - fly the same direction
							float threshDelta = alignmentThresh - separationThresh;
							float adjustedPercent = ( percent - separationThresh ) / threshDelta;

							birdVelocity = texture2D( textureVelocity, ref ).xyz;

							f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;
							velocity += normalize(birdVelocity) * f;

						} else {

							// Attraction / Cohesion - move closer
							float threshDelta = 1.0 - alignmentThresh;
							float adjustedPercent = ( percent - alignmentThresh ) / threshDelta;

							f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;

							velocity += normalize(dir) * f;

						}

					}

				}



				// this make tends to fly around than down or up
				 if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);

				// Speed Limits
				if ( length( velocity ) > limit ) {
					velocity = normalize( velocity ) * limit;
				}

				gl_FragColor = vec4( velocity, 1.0 );

			}

		</script>

    <script type="x-shader/x-vertex" id="birdVS">

			attribute vec2 reference;
			attribute float birdVertex;

			attribute vec3 birdColor;

			uniform sampler2D texturePosition;
			uniform sampler2D textureVelocity;

			varying vec4 vColor;
			varying float z;

			uniform float time;

			void main() {

				vec4 tmpPos = texture2D( texturePosition, reference );
				vec3 pos = tmpPos.xyz;
				vec3 velocity = normalize(texture2D( textureVelocity, reference ).xyz);

				vec3 newPosition = position;

				if ( birdVertex == 4.0 || birdVertex == 7.0 ) {
					// flap wings
					newPosition.y = sin( tmpPos.w ) * 5.;
				}
				if(birdVertex == 2.0)
					newPosition.y = -sin( tmpPos.w ) * 0.5;

				newPosition = mat3( modelMatrix ) * newPosition;


				velocity.z *= -1.;
				float xz = length( velocity.xz );
				float xyz = 1.;
				float x = sqrt( 1. - velocity.y * velocity.y );

				float cosry = velocity.x / xz;
				float sinry = velocity.z / xz;

				float cosrz = x / xyz;
				float sinrz = velocity.y / xyz;

				mat3 maty =  mat3(
					cosry, 0, -sinry,
					0    , 1, 0     ,
					sinry, 0, cosry

				);

				mat3 matz =  mat3(
					cosrz , sinrz, 0,
					-sinrz, cosrz, 0,
					0     , 0    , 1
				);

				newPosition =  maty * matz * newPosition;
				newPosition += pos;

				z = newPosition.z;

				vColor = vec4( birdColor, 1.0 );
				gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );
			}

		</script>

    <!-- bird geometry shader -->
    <script type="x-shader/x-fragment" id="birdFS">

			varying vec4 vColor;
			varying float z;

			uniform vec3 color;

			void main() {
				// Fake colors for now
				float z2 = 0.2 + ( 1000. - z ) / 1000. * vColor.x;
				 float zb = 0.2 + ( 1000. - z ) / 1000. * vColor.y;
				 float zg = 0.2 + ( 1000. - z ) / 1000. * vColor.z;


				// gl_FragColor = vec4( z2, zb, zg, 1.0 );
				 gl_FragColor = vColor;

			}

		</script>
    <script id="fragmentShader" type="x-shader/x-fragment">

			uniform float time;
			uniform vec2 resolution;

			uniform float fogDensity;
			uniform vec3 fogColor;

			uniform sampler2D texture1;
			uniform sampler2D texture2;

			varying vec2 vUv;

			void main( void ) {

				vec2 position = -1.0 + 2.0 * vUv;

				vec4 noise = texture2D( texture1, vUv );
				vec2 T1 = vUv + vec2( 1.5, -1.5 ) * time  *0.02;
				vec2 T2 = vUv + vec2( -0.5, 2.0 ) * time * 0.01;

				T1.x += noise.x * 2.0;
				T1.y += noise.y * 2.0;
				T2.x -= noise.y * 0.2;
				T2.y += noise.z * 0.2;

				float p = texture2D( texture1, T1 * 2.0 ).a;

				vec4 color = texture2D( texture2, T2 * 2.0 );
				vec4 temp = color * ( vec4( p, p, p, p ) * 2.0 ) + ( color * color - 0.1 );

				if( temp.r > 1.0 ){ temp.bg += clamp( temp.r - 2.0, 0.0, 100.0 ); }
				if( temp.g > 1.0 ){ temp.rb += temp.g - 1.0; }
				if( temp.b > 1.0 ){ temp.rg += temp.b - 1.0; }

				gl_FragColor = temp;

				float depth = gl_FragCoord.z / gl_FragCoord.w;
				const float LOG2 = 1.442695;
				float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );
				fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );

				gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

			}

		</script>

    <script id="vertexShader" type="x-shader/x-vertex">

			uniform vec2 uvScale;
			varying vec2 vUv;

			void main()
			{

				vUv = uvScale * uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

    <script>

        if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

        var hash = document.location.hash.substr( 1 );
        if (hash) hash = parseInt(hash, 0);

        //console.log(hash);
        /* TEXTURE WIDTH FOR SIMULATION */
        var WIDTH = hash || 64;

        var BIRDS = WIDTH * WIDTH;

        // Custom Geometry - using 3 triangles each. No UVs, no normals currently.
        THREE.BirdGeometry = function () {

            var triangles = BIRDS * 3;
            var points = triangles * 3;

            THREE.BufferGeometry.call( this );

            var vertices = new THREE.BufferAttribute( new Float32Array( points * 3 ), 3 );
            var birdColors = new THREE.BufferAttribute( new Float32Array( points * 3 ), 3 );
            var references = new THREE.BufferAttribute( new Float32Array( points * 2 ), 2 );
            var birdVertex = new THREE.BufferAttribute( new Float32Array( points ), 1 );

            this.addAttribute( 'position', vertices );
            this.addAttribute( 'birdColor', birdColors );
            this.addAttribute( 'reference', references );
            this.addAttribute( 'birdVertex', birdVertex );

            // this.addAttribute( 'normal', new Float32Array( points * 3 ), 3 );


            var v = 0;

            function verts_push() {
                for (var i=0; i < arguments.length; i++) {
                    vertices.array[v] = arguments[i];
                    v++;
                }
            }

            var wingsSpan = 20;

            for (var f = 0; f<BIRDS; f++ ) {

                // Body
                verts_push(
                    0, -0, -20,
                    0, 4, -20,
                    0, 0, 30
                );

                // Left Wing
                verts_push(
                    0, 0, -15,
                    -wingsSpan, 0, 0,
                    0, 0, 15
                );

                // Right Wing
                verts_push(
                    0, 0, 15,
                    wingsSpan, 0, 0,
                    0, 0, -15
                );

            }

            for( var v = 0; v < triangles * 3; v++ ) {

                var i = ~~(v / 9);
                var x = (i % WIDTH) / WIDTH;
                // var x = (i % WIDTH) / WIDTH;

                var y = (i / WIDTH) / WIDTH;

                var c = new THREE.Color(
                    0x222222 +
//						  ~~(v / 9) / BIRDS * 0x888888
                    (Math.floor(v / 9)*0.1)* 0x666666
                );
                // console.log(c.r+":"+Math.floor(v/9));

                birdColors.array[ v * 3 + 0 ] = c.r;
                birdColors.array[ v * 3 + 1 ] = c.g;
                birdColors.array[ v * 3 + 2 ] = c.b;

                references.array[ v * 2     ] = x;
                references.array[ v * 2 + 1 ] = y;

                birdVertex.array[ v         ] = v % 9;

            }

            this.scale( 0.2, 0.2, 0.2 );
            // console.log(birdColors);

        };
        THREE.BirdGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );


        var container, stats;
        var camera, scene, renderer, geometry, i, h, color;
        var mouseX = 0, mouseY = 0;

        var windowHalfX = window.innerWidth / 2;
        var windowHalfY = window.innerHeight / 2;

        var BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;

       // document.getElementById('birds').innerText = BIRDS;

        function change(n) {
            location.hash = n;
            location.reload();
            return false;
        }


//        var options = '';
//        for (i=1; i<7; i++) {
//            var j = Math.pow(2, i);
//            options += '<a href="#" onclick="return change(' + j + ')">' + (j * j) + '</a> ';
//        }
//        document.getElementById('options').innerHTML = options;

        var last = performance.now();

        var gpuCompute;
        var velocityVariable;
        var positionVariable;
        var positionUniforms;
        var velocityUniforms;
        var birdUniforms;
        var mesh2;
        var uniforms2;
        var clock = new THREE.Clock();
        init();
        animate();

        function init() {

            container = document.createElement( 'div' );
            container.style.position="absolute";
            container.style.top = "-0";
            document.body.appendChild( container );

            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
            camera.position.z = 350;

            var light = new THREE.DirectionalLight(0xffffff);

            scene = new THREE.Scene();
            scene.add(light);
            // scene.fog = new THREE.Fog( 0xffffff, 100, 1000 );

            renderer = new THREE.WebGLRenderer({ antialias: true,alpha:true });
            renderer.setClearColor( 0xffffff,0);
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );
            // renderer.autoClear = false;

            initComputeRenderer();

           // stats = new Stats();
           //  container.appendChild( stats.dom );

            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'touchstart', onDocumentTouchStart, false );
            document.addEventListener( 'touchmove', onDocumentTouchMove, false );

            //

            window.addEventListener( 'resize', onWindowResize, false );



           // var gui = new dat.GUI();


            var effectController = {
                seperation: 20.0,
                alignment: 20.0,
                cohesion: 20.0,
                freedom: 0.75
            };

            var valuesChanger = function() {

                velocityUniforms.seperationDistance.value = effectController.seperation;
                velocityUniforms.alignmentDistance.value = effectController.alignment;
                velocityUniforms.cohesionDistance.value = effectController.cohesion;
                velocityUniforms.freedomFactor.value = effectController.freedom;

            };

            valuesChanger();


//            gui.add( effectController, "seperation", 0.0, 100.0, 1.0 ).onChange( valuesChanger );
//            gui.add( effectController, "alignment", 0.0, 100, 0.001 ).onChange( valuesChanger );
//            gui.add( effectController, "cohesion", 0.0, 100, 0.025 ).onChange( valuesChanger );
//            gui.close();

            initBirds();
//				var centerMesh = new THREE.M

            var textureLoader = new THREE.TextureLoader();

            uniforms2 = {

                fogDensity: { value: 0.0 },
                fogColor:   { value: new THREE.Vector3( 0, 0, 0 ) },
                time:       { value: 1.0 },
                resolution: { value: new THREE.Vector2() },
                uvScale:    { value: new THREE.Vector2( 3.0, 1.0 ) },
                texture1:   { value: textureLoader.load( "textures/lava/cloud.png" ) },
                texture2:   { value: textureLoader.load( "textures/lava/lavatile.jpg" ) }

            };

            uniforms2.texture1.value.wrapS = uniforms2.texture1.value.wrapT = THREE.RepeatWrapping;
            uniforms2.texture2.value.wrapS = uniforms2.texture2.value.wrapT = THREE.RepeatWrapping;

            var size = 40;

            var  material2 = new THREE.ShaderMaterial( {

                uniforms: uniforms2,
                vertexShader: document.getElementById( 'vertexShader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentShader' ).textContent

            } );

            mesh2 = new THREE.Mesh( new THREE.SphereGeometry( size, 100, 108 ), material2 );
//                mesh2.scale.x = 100;
//                mesh2.scale.y = 100;
//                mesh2.scale.z = 100;

            scene.add( mesh2 );
        }

        function initComputeRenderer() {

            gpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );

            var dtPosition = gpuCompute.createTexture();
            var dtVelocity = gpuCompute.createTexture();
            fillPositionTexture( dtPosition );
            fillVelocityTexture( dtVelocity );

            velocityVariable = gpuCompute.addVariable( "textureVelocity", document.getElementById( 'fragmentShaderVelocity' ).textContent, dtVelocity );
            positionVariable = gpuCompute.addVariable( "texturePosition", document.getElementById( 'fragmentShaderPosition' ).textContent, dtPosition );

            gpuCompute.setVariableDependencies( velocityVariable, [ positionVariable, velocityVariable ] );
            gpuCompute.setVariableDependencies( positionVariable, [ positionVariable, velocityVariable ] );

            positionUniforms = positionVariable.material.uniforms;
            velocityUniforms = velocityVariable.material.uniforms;

            positionUniforms.time = { value: 0.0 };
            positionUniforms.delta = { value: 0.0 };
            velocityUniforms.time = { value: 1.0 };
            velocityUniforms.delta = { value: 0.0 };
            velocityUniforms.testing = { value: 1.0 };
            velocityUniforms.seperationDistance = { value: 1.0 };
            velocityUniforms.alignmentDistance = { value: 1.0 };
            velocityUniforms.cohesionDistance = { value: 1.0 };
            velocityUniforms.freedomFactor = { value: 1.0 };
            velocityUniforms.predator = { value: new THREE.Vector3() };
            velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed( 2 );

            velocityVariable.wrapS = THREE.RepeatWrapping;
            velocityVariable.wrapT = THREE.RepeatWrapping;
            positionVariable.wrapS = THREE.RepeatWrapping;
            positionVariable.wrapT = THREE.RepeatWrapping;

            var error = gpuCompute.init();
            if ( error !== null ) {
                console.error( error );
            }

        }

        function initBirds() {

            var geometry = new THREE.BirdGeometry();

            // For Vertex and Fragment
            birdUniforms = {
                // color: { value: new THREE.Color( 0x000000 ) },
                texturePosition: { value: null },
                textureVelocity: { value: null },
                time: { value: 1.0 },
                delta: { value: 0.0 }
            };

            // ShaderMaterial
            var material = new THREE.ShaderMaterial( {
                uniforms:       birdUniforms,
                vertexShader:   document.getElementById( 'birdVS' ).textContent,
                fragmentShader: document.getElementById( 'birdFS' ).textContent,
                side: THREE.DoubleSide

            });

            birdMesh = new THREE.Mesh( geometry, material );
            birdMesh.rotation.y = Math.PI / 2;
            birdMesh.matrixAutoUpdate = false;
            birdMesh.updateMatrix();
            birdMesh.scale = 9;
            scene.add(birdMesh);

        }

        function fillPositionTexture( texture ) {

            var theArray = texture.image.data;

            for ( var k = 0, kl = theArray.length; k < kl; k += 4 ) {

                var x = Math.random() * BOUNDS - BOUNDS_HALF;
                var y = Math.random() * BOUNDS - BOUNDS_HALF;
                var z = Math.random() * BOUNDS - BOUNDS_HALF;

                theArray[ k + 0 ] = x;
                theArray[ k + 1 ] = y;
                theArray[ k + 2 ] = z;
                theArray[ k + 3 ] = 1;

            }

        }

        function fillVelocityTexture( texture ) {

            var theArray = texture.image.data;

            for ( var k = 0, kl = theArray.length; k < kl; k += 4 ) {

                var x = Math.random() - 0.5;
                var y = Math.random() - 0.5;
                var z = Math.random() - 0.5;

                theArray[ k + 0 ] = x * 10;
                theArray[ k + 1 ] = y * 10;
                theArray[ k + 2 ] = z * 10;
                theArray[ k + 3 ] = 1;

            }

        }


        function onWindowResize() {

            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function onDocumentMouseMove( event ) {

            mouseX = event.clientX - windowHalfX;
            mouseY = event.clientY - windowHalfY;

        }

        function onDocumentTouchStart( event ) {

            if ( event.touches.length === 1 ) {

                event.preventDefault();

                mouseX = event.touches[ 0 ].pageX - windowHalfX;
                mouseY = event.touches[ 0 ].pageY - windowHalfY;

            }

        }

        function onDocumentTouchMove( event ) {

            if ( event.touches.length === 1 ) {

                event.preventDefault();

                mouseX = event.touches[ 0 ].pageX - windowHalfX;
                mouseY = event.touches[ 0 ].pageY - windowHalfY;

            }

        }

        //

        function animate() {

            requestAnimationFrame( animate );

            render();
//            stats.update();

        }

        function render() {
            var delta = 0.75 * clock.getDelta();
            var now = performance.now();
//                var delta = (now - last) / 1000;
            uniforms2.time.value += 2.2 * delta;

            mesh2.rotation.y += 0.0125 * delta;
//                mesh2.rotation.x += 0.05 * delta;



            if (delta > 1) delta = 1; // safety cap on large deltas
            last = now;

            positionUniforms.time.value = now;
            positionUniforms.delta.value = delta;
            velocityUniforms.time.value = now;
            velocityUniforms.delta.value = delta;
            birdUniforms.time.value = now;
            birdUniforms.delta.value = delta;

            if(mouseX > 9000)
                mouseX = 0;
            if(mouseY > 9000)
                mouseY = 0;
            velocityUniforms.predator.value.set( 0.5 * mouseX / windowHalfX, - 0.5 * mouseY / windowHalfY, 0 );

				mouseX = 10000;
				mouseY = 10000;

            gpuCompute.compute();

            birdUniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget( positionVariable ).texture;
            birdUniforms.textureVelocity.value = gpuCompute.getCurrentRenderTarget( velocityVariable ).texture;

            renderer.render( scene, camera );

        }

    </script>


  </body>
</html>
